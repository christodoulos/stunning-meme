{"ast":null,"code":"import { parser } from '@lezer/python';\nimport { LRLanguage, indentNodeProp, delimitedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\nimport { styleTags, tags } from '@codemirror/highlight';\n\nfunction indentBody(context, node) {\n  let base = context.lineIndent(node.from);\n  let line = context.lineAt(context.pos, -1),\n      to = line.from + line.text.length; // Don't consider blank, deindented lines at the end of the\n  // block part of the block\n\n  if (!/\\S/.test(line.text) && context.node.to < to + 100 && !/\\S/.test(context.state.sliceDoc(to, context.node.to)) && context.lineIndent(context.pos, -1) <= base) return null; // A normally deindenting keyword that appears at a higher\n  // indentation than the block should probably be handled by the next\n  // level\n\n  if (/^\\s*(else:|elif |except |finally:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base) return null;\n  return base + context.unit;\n}\n/**\nA language provider based on the [Lezer Python\nparser](https://github.com/lezer-parser/python), extended with\nhighlighting and indentation information.\n*/\n\n\nconst pythonLanguage = /*@__PURE__*/LRLanguage.define({\n  parser: /*@__PURE__*/parser.configure({\n    props: [/*@__PURE__*/indentNodeProp.add({\n      Body: context => {\n        var _a;\n\n        return (_a = indentBody(context, context.node)) !== null && _a !== void 0 ? _a : context.continue();\n      },\n      IfStatement: cx => /^\\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n      TryStatement: cx => /^\\s*(except |finally:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n      \"TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression\": /*@__PURE__*/delimitedIndent({\n        closing: \")\"\n      }),\n      \"DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression\": /*@__PURE__*/delimitedIndent({\n        closing: \"}\"\n      }),\n      \"ArrayExpression ArrayComprehensionExpression\": /*@__PURE__*/delimitedIndent({\n        closing: \"]\"\n      }),\n      Script: context => {\n        if (context.pos + /\\s*/.exec(context.textAfter)[0].length >= context.node.to) {\n          let endBody = null;\n\n          for (let cur = context.node, to = cur.to;;) {\n            cur = cur.lastChild;\n            if (!cur || cur.to != to) break;\n            if (cur.type.name == \"Body\") endBody = cur;\n          }\n\n          if (endBody) {\n            let bodyIndent = indentBody(context, endBody);\n            if (bodyIndent != null) return bodyIndent;\n          }\n        }\n\n        return context.continue();\n      }\n    }), /*@__PURE__*/foldNodeProp.add({\n      \"Body ArrayExpression DictionaryExpression\": foldInside\n    }), /*@__PURE__*/styleTags({\n      \"async '*' '**' FormatConversion\": tags.modifier,\n      \"for while if elif else try except finally return raise break continue with pass assert await yield\": tags.controlKeyword,\n      \"in not and or is del\": tags.operatorKeyword,\n      \"import from def class global nonlocal lambda\": tags.definitionKeyword,\n      \"with as print\": tags.keyword,\n      self: tags.self,\n      Boolean: tags.bool,\n      None: tags.null,\n      VariableName: tags.variableName,\n      \"CallExpression/VariableName\": /*@__PURE__*/tags.function(tags.variableName),\n      \"FunctionDefinition/VariableName\": /*@__PURE__*/tags.function( /*@__PURE__*/tags.definition(tags.variableName)),\n      \"ClassDefinition/VariableName\": /*@__PURE__*/tags.definition(tags.className),\n      PropertyName: tags.propertyName,\n      \"CallExpression/MemberExpression/PropertyName\": /*@__PURE__*/tags.function(tags.propertyName),\n      Comment: tags.lineComment,\n      Number: tags.number,\n      String: tags.string,\n      FormatString: /*@__PURE__*/tags.special(tags.string),\n      UpdateOp: tags.updateOperator,\n      ArithOp: tags.arithmeticOperator,\n      BitOp: tags.bitwiseOperator,\n      CompareOp: tags.compareOperator,\n      AssignOp: tags.definitionOperator,\n      Ellipsis: tags.punctuation,\n      At: tags.meta,\n      \"( )\": tags.paren,\n      \"[ ]\": tags.squareBracket,\n      \"{ }\": tags.brace,\n      \".\": tags.derefOperator,\n      \", ;\": tags.separator\n    })]\n  }),\n  languageData: {\n    closeBrackets: {\n      brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"'''\", '\"\"\"']\n    },\n    commentTokens: {\n      line: \"#\"\n    },\n    indentOnInput: /^\\s*([\\}\\]\\)]|else:|elif |except |finally:)$/\n  }\n});\n/**\nPython language support.\n*/\n\nfunction python() {\n  return new LanguageSupport(pythonLanguage);\n}\n\nexport { python, pythonLanguage };","map":{"version":3,"sources":["/home/christodoulos/Workspace/nocode/node_modules/@codemirror/lang-python/dist/index.js"],"names":["parser","LRLanguage","indentNodeProp","delimitedIndent","foldNodeProp","foldInside","LanguageSupport","styleTags","tags","indentBody","context","node","base","lineIndent","from","line","lineAt","pos","to","text","length","test","state","sliceDoc","textAfter","unit","pythonLanguage","define","configure","props","add","Body","_a","continue","IfStatement","cx","baseIndent","TryStatement","closing","Script","exec","endBody","cur","lastChild","type","name","bodyIndent","modifier","controlKeyword","operatorKeyword","definitionKeyword","keyword","self","Boolean","bool","None","null","VariableName","variableName","function","definition","className","PropertyName","propertyName","Comment","lineComment","Number","number","String","string","FormatString","special","UpdateOp","updateOperator","ArithOp","arithmeticOperator","BitOp","bitwiseOperator","CompareOp","compareOperator","AssignOp","definitionOperator","Ellipsis","punctuation","At","meta","paren","squareBracket","brace","derefOperator","separator","languageData","closeBrackets","brackets","commentTokens","indentOnInput","python"],"mappings":"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","sourcesContent":["import { parser } from '@lezer/python';\nimport { LRLanguage, indentNodeProp, delimitedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\nimport { styleTags, tags } from '@codemirror/highlight';\n\nfunction indentBody(context, node) {\n    let base = context.lineIndent(node.from);\n    let line = context.lineAt(context.pos, -1), to = line.from + line.text.length;\n    // Don't consider blank, deindented lines at the end of the\n    // block part of the block\n    if (!/\\S/.test(line.text) &&\n        context.node.to < to + 100 &&\n        !/\\S/.test(context.state.sliceDoc(to, context.node.to)) &&\n        context.lineIndent(context.pos, -1) <= base)\n        return null;\n    // A normally deindenting keyword that appears at a higher\n    // indentation than the block should probably be handled by the next\n    // level\n    if (/^\\s*(else:|elif |except |finally:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base)\n        return null;\n    return base + context.unit;\n}\n/**\nA language provider based on the [Lezer Python\nparser](https://github.com/lezer-parser/python), extended with\nhighlighting and indentation information.\n*/\nconst pythonLanguage = /*@__PURE__*/LRLanguage.define({\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                Body: context => { var _a; return (_a = indentBody(context, context.node)) !== null && _a !== void 0 ? _a : context.continue(); },\n                IfStatement: cx => /^\\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n                TryStatement: cx => /^\\s*(except |finally:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n                \"TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression\": /*@__PURE__*/delimitedIndent({ closing: \")\" }),\n                \"DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression\": /*@__PURE__*/delimitedIndent({ closing: \"}\" }),\n                \"ArrayExpression ArrayComprehensionExpression\": /*@__PURE__*/delimitedIndent({ closing: \"]\" }),\n                Script: context => {\n                    if (context.pos + /\\s*/.exec(context.textAfter)[0].length >= context.node.to) {\n                        let endBody = null;\n                        for (let cur = context.node, to = cur.to;;) {\n                            cur = cur.lastChild;\n                            if (!cur || cur.to != to)\n                                break;\n                            if (cur.type.name == \"Body\")\n                                endBody = cur;\n                        }\n                        if (endBody) {\n                            let bodyIndent = indentBody(context, endBody);\n                            if (bodyIndent != null)\n                                return bodyIndent;\n                        }\n                    }\n                    return context.continue();\n                }\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                \"Body ArrayExpression DictionaryExpression\": foldInside\n            }),\n            /*@__PURE__*/styleTags({\n                \"async '*' '**' FormatConversion\": tags.modifier,\n                \"for while if elif else try except finally return raise break continue with pass assert await yield\": tags.controlKeyword,\n                \"in not and or is del\": tags.operatorKeyword,\n                \"import from def class global nonlocal lambda\": tags.definitionKeyword,\n                \"with as print\": tags.keyword,\n                self: tags.self,\n                Boolean: tags.bool,\n                None: tags.null,\n                VariableName: tags.variableName,\n                \"CallExpression/VariableName\": /*@__PURE__*/tags.function(tags.variableName),\n                \"FunctionDefinition/VariableName\": /*@__PURE__*/tags.function(/*@__PURE__*/tags.definition(tags.variableName)),\n                \"ClassDefinition/VariableName\": /*@__PURE__*/tags.definition(tags.className),\n                PropertyName: tags.propertyName,\n                \"CallExpression/MemberExpression/PropertyName\": /*@__PURE__*/tags.function(tags.propertyName),\n                Comment: tags.lineComment,\n                Number: tags.number,\n                String: tags.string,\n                FormatString: /*@__PURE__*/tags.special(tags.string),\n                UpdateOp: tags.updateOperator,\n                ArithOp: tags.arithmeticOperator,\n                BitOp: tags.bitwiseOperator,\n                CompareOp: tags.compareOperator,\n                AssignOp: tags.definitionOperator,\n                Ellipsis: tags.punctuation,\n                At: tags.meta,\n                \"( )\": tags.paren,\n                \"[ ]\": tags.squareBracket,\n                \"{ }\": tags.brace,\n                \".\": tags.derefOperator,\n                \", ;\": tags.separator\n            })\n        ],\n    }),\n    languageData: {\n        closeBrackets: { brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"'''\", '\"\"\"'] },\n        commentTokens: { line: \"#\" },\n        indentOnInput: /^\\s*([\\}\\]\\)]|else:|elif |except |finally:)$/\n    }\n});\n/**\nPython language support.\n*/\nfunction python() {\n    return new LanguageSupport(pythonLanguage);\n}\n\nexport { python, pythonLanguage };\n"]},"metadata":{},"sourceType":"module"}